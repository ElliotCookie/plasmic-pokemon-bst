// pages/[[...catchall]].tsx
import * as React from "react";
import {
  PlasmicComponent,
  extractPlasmicQueryData,
  ComponentRenderData,
  PlasmicRootProvider,
} from "@plasmicapp/loader-nextjs";
import type { GetStaticPaths, GetStaticProps } from "next";
import Error from "next/error";
import { useRouter } from "next/router";
import { PLASMIC } from "@/plasmic-init";

/**
 * Plasmic loader page that:
 * - fetches Plasmic page data at build time (getStaticProps/getStaticPaths)
 * - mounts a client-side slider that POSTs to your PythonAnywhere backend
 * - shows an initial number fetched from /number on load
 * - displays multiply result in the multiplyBox child component
 */

export default function PlasmicLoaderPage(props: {
  plasmicData?: ComponentRenderData;
  queryCache?: Record<string, unknown>;
}) {
  const { plasmicData, queryCache } = props;
  const router = useRouter();

  // -----------------------
  // Top-level Hooks (must be here)
  // -----------------------
  const [sliderValue, setSliderValue] = React.useState<number>(0);
  const [initialNumber, setInitialNumber] = React.useState<string>("loading...");
  const [multiplyResultPa, setMultiplyResultPa] = React.useState<number | null>(null);

  // Backend base URL: use env in production, fallback to your PA domain for local dev
  const BACKEND = process.env.NEXT_PUBLIC_BACKEND_URL ?? "https://elliotcookie.pythonanywhere.com";

  // Fetch initial number once on client-side mount
  React.useEffect(() => {
    console.log("ðŸ“¥ Fetching initial /number from PythonAnywhere...");
    fetch(`${BACKEND}/number`)
      .then((res) => res.json())
      .then((data) => {
        console.log("API fetch /number result:", data);
        if (data && data.result !== undefined) {
          setInitialNumber(String(data.result));
        }
      })
      .catch((err) => {
        console.error("Error fetching initial number:", err);
        setInitialNumber("error");
      });
  }, [BACKEND]);

  // Handler called when slider changes in Plasmic
  async function onValueChange(newSliderValue: number) {
    try {
      // immediate UI update
      setSliderValue(newSliderValue);
      console.log("Slider event - newSliderValue:", newSliderValue);

      // POST to backend once
      console.log("ðŸ“¤ About to POST to /multiply with:", { value: newSliderValue });
      const res = await fetch(`${BACKEND}/multiply`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ value: newSliderValue }),
      });
      console.log("Response status:", res.status);

      let json: any = null;
      try {
        json = await res.json();
      } catch (parseErr) {
        console.warn("Response not JSON or parse failed", parseErr);
      }

      if (res.ok && json && json.result !== undefined) {
        const numericResult = Number(json.result);
        setMultiplyResultPa(numericResult);
        console.log("API response data:", json);
      } else {
        console.warn("API error or no result:", res.status, json);
        setMultiplyResultPa(null);
      }
    } catch (err) {
      console.error("Error calling API:", err);
      setMultiplyResultPa(null);
    }
  }

  // Keep the Plasmic required early-return after hooks.
  if (!plasmicData || plasmicData.entryCompMetas.length === 0) {
    return <Error statusCode={404} />;
  }
  const pageMeta = plasmicData.entryCompMetas[0];

  // Map component props to Plasmic children (names must match your Plasmic component display names / props)
  const componentProps = {
    testSlider1: {
      // NOTE: make sure the prop name here (value) matches the prop name in Plasmic for the slider
      Value: sliderValue, // if Plasmic expects `Value` (capital V) â€” use that. Match what you configured.
      onValueChange: onValueChange,
    },
    apiTestTextBox: {
      // the text prop in your Plasmic text box (match exactly)
      text: initialNumber,
    },
    multiplyBox: {
      // the prop name you set in Plasmic for the multiply box (valueMb or similar). Adjust if different.
      valueMb: multiplyResultPa !== null ? String(multiplyResultPa) : "",
    },
  };

  return (
    <PlasmicRootProvider
      loader={PLASMIC}
      prefetchedData={plasmicData}
      prefetchedQueryData={queryCache as any}
      pageRoute={pageMeta.path}
      pageParams={pageMeta.params}
      pageQuery={router.query}
    >
      <PlasmicComponent component={pageMeta.displayName} componentProps={componentProps} />
    </PlasmicRootProvider>
  );
}

/**
 * keep getStaticProps/getStaticPaths generated by Plasmic so pages are discovered and pre-rendered.
 * These were the typical Plasmic-generated implementations â€” they must exist for the catchall route.
 */

export const getStaticProps: GetStaticProps = async (context) => {
  const { catchall } = context.params ?? {};
  const plasmicPath =
    typeof catchall === "string"
      ? catchall
      : Array.isArray(catchall)
      ? `/${catchall.join("/")}`
      : "/";
  const plasmicData = await PLASMIC.maybeFetchComponentData(plasmicPath);
  if (!plasmicData) {
    // non-Plasmic catch-all
    return { props: {} };
  }
  const pageMeta = plasmicData.entryCompMetas[0];

  // extractPlasmicQueryData runs a prepass to gather data used by components (keep as-is)
  const queryCache = await extractPlasmicQueryData(
    <PlasmicRootProvider loader={PLASMIC} prefetchedData={plasmicData} pageRoute={pageMeta.path} pageParams={pageMeta.params}>
      <PlasmicComponent component={pageMeta.displayName} />
    </PlasmicRootProvider>
  );

  return { props: { plasmicData, queryCache }, revalidate: 60 };
};

export const getStaticPaths: GetStaticPaths = async () => {
  const pageModules = await PLASMIC.fetchPages();
  return {
    paths: pageModules.map((mod) => ({
      params: {
        catchall: mod.path.substring(1).split("/"),
      },
    })),
    fallback: "blocking",
  };
};
